

-- Environment Check
if not (Drawing and Drawing.new) then
    warn('[Eisha] Drawing API not available. ESP features will be disabled.')
end

local repo = 'https://raw.githubusercontent.com/deividcomsono/Obsidian/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- ADONIS ANTI-CHEAT BYPASS
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

task.spawn(function()
    local getgc = getgc or debug.getgc
    local hookfunction = hookfunction
    local getrenv = getrenv
    local debugInfo = (getrenv and getrenv().debug and getrenv().debug.info) or debug.info
    local newcclosure = newcclosure or function(f) return f end

    if not (getgc and hookfunction and getrenv and debugInfo) then
        return
    end

    local DetectedMeth, KillMeth
    local AdonisFound = false

    -- Detect Adonis
    for _, value in getgc(true) do
        if typeof(value) == 'table' then
            local hasDetected = typeof(rawget(value, 'Detected')) == 'function'
            local hasKill = typeof(rawget(value, 'Kill')) == 'function'
            local hasVars = rawget(value, 'Variables') ~= nil
            local hasProcess = rawget(value, 'Process') ~= nil

            if hasDetected or (hasKill and hasVars and hasProcess) then
                AdonisFound = true
                break
            end
        end
    end

    if not AdonisFound then
        return
    end

    -- Hook Adonis methods
    for _, value in getgc(true) do
        if typeof(value) == 'table' then
            local detected = rawget(value, 'Detected')
            local kill = rawget(value, 'Kill')

            if typeof(detected) == 'function' and not DetectedMeth then
                DetectedMeth = detected
                hookfunction(DetectedMeth, function()
                    return true
                end)
            end

            if rawget(value, 'Variables') and rawget(value, 'Process') and typeof(kill) == 'function' and not KillMeth then
                KillMeth = kill
                hookfunction(KillMeth, function() end)
            end
        end
    end

    -- Hook debug.info
    if DetectedMeth and debugInfo then
        local originalDebugInfo = hookfunction(debugInfo, newcclosure(function(...)
            local functionName = ...
            if functionName == DetectedMeth then
                return coroutine.yield(coroutine.running())
            end
            return originalDebugInfo(...)
        end))
    end

    -- Notify after Library is loaded
    task.wait(2)
    if Library and Library.Notify then
        Library:Notify({
            Title = 'Anti-Cheat',
            Description = 'Bypassed Anti Cheat',
            Time = 5,
        })
    end
end)

local Options = Library.Options
local Toggles = Library.Toggles

-- Services
local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local UserInputService = game:GetService('UserInputService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Workspace = game:GetService('Workspace')

-- Player
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild('HumanoidRootPart')
local Camera = workspace.CurrentCamera

-- Remotes
local FightsFolder = ReplicatedStorage:WaitForChild('Fights')
local PlayerTurnInput = ReplicatedStorage:WaitForChild('PlayerTurnInput')
local RemoteFunction = ReplicatedStorage:WaitForChild('Remotes'):WaitForChild('Information'):WaitForChild('RemoteFunction')
local InventoryManage = ReplicatedStorage:WaitForChild('Remotes'):WaitForChild('Information'):WaitForChild('InventoryManage')

-- Update Character on respawn
LocalPlayer.CharacterAdded:Connect(function(newChar)
    Character = newChar
    HumanoidRootPart = newChar:WaitForChild('HumanoidRootPart')
end)

-- Window
local Window = Library:CreateWindow({
    Title = 'Eisha',
    Footer = '<font color="rgb(0,255,0)">Safe</font>',
    Icon = 4483362458,
    NotifySide = 'Right',
    ShowCustomCursor = true,
    MobileButtonsSide = 'Right',
})

-- Tabs
local Tabs = {
    Main = Window:AddTab('Main', 'home'),
    ['UI Settings'] = Window:AddTab('UI Settings', 'settings'),
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- ESP SYSTEM
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

local ESP_NPC = {}

local function dist(p)
    if not p or not HumanoidRootPart or not HumanoidRootPart.Parent then
        return math.huge
    end
    return (HumanoidRootPart.Position - p.Position).Magnitude
end

local function newSquare(thickness, color)
    local sq = Drawing.new('Square')
    sq.Visible = false
    sq.Color = color
    sq.Thickness = thickness
    sq.Filled = false
    return sq
end

local function newText(size, color)
    local txt = Drawing.new('Text')
    txt.Visible = false
    txt.Color = color
    txt.Size = size
    txt.Center = true
    txt.Outline = true
    return txt
end

local function cleanNpcEsp(npc)
    if ESP_NPC[npc] then
        if ESP_NPC[npc].conn then
            ESP_NPC[npc].conn:Disconnect()
        end
        if ESP_NPC[npc].ancConn then
            ESP_NPC[npc].ancConn:Disconnect()
        end
        if ESP_NPC[npc].draw then
            for _, d in ipairs(ESP_NPC[npc].draw) do
                if d then
                    d:Remove()
                end
            end
        end
    end
    ESP_NPC[npc] = nil
end

local espSettings = {
    Enabled = false,
    BoxColor = Color3.fromRGB(255, 255, 255),
    BoxThickness = 1,
    BoxTransparency = 1,
    NameColor = Color3.fromRGB(255, 255, 255),
    NameSize = 13,
    HealthColor = Color3.fromRGB(0, 255, 0),
    HealthSize = 13,
    MaxDistance = 500,
    UpdateRate = 0.1,
}

local function buildNpcEsp(npc)
    cleanNpcEsp(npc)
    if not npc then
        return
    end

    local hum = npc:FindFirstChildOfClass('Humanoid')
    local hrp = npc:FindFirstChild('HumanoidRootPart')
    local head = npc:FindFirstChild('Head')

    if not (hum and hrp and head) then
        return
    end

    local boxO = newSquare(3, Color3.new())
    local box = newSquare(espSettings.BoxThickness, espSettings.BoxColor)
    local hpBar = newSquare(2, Color3.new())
    local nameT = newText(espSettings.NameSize, espSettings.NameColor)
    local hpT = newText(espSettings.HealthSize, espSettings.HealthColor)

    local lastUpdate = 0
    local conn
    conn = RunService.RenderStepped:Connect(function()
        if not espSettings.Enabled then
            for _, d in ipairs({ box, boxO, hpBar, nameT, hpT }) do
                d.Visible = false
            end
            return
        end

        if not hum or hum.Health <= 0 or not npc:IsDescendantOf(workspace) then
            cleanNpcEsp(npc)
            return
        end

        local now = tick()
        if now - lastUpdate < espSettings.UpdateRate then
            return
        end
        lastUpdate = now

        local distance = dist(hrp)
        if distance > espSettings.MaxDistance then
            for _, d in ipairs({ box, boxO, hpBar, nameT, hpT }) do
                d.Visible = false
            end
            return
        end

        box.Color = espSettings.BoxColor
        box.Thickness = espSettings.BoxThickness
        nameT.Color = espSettings.NameColor
        nameT.Size = espSettings.NameSize
        hpT.Color = espSettings.HealthColor
        hpT.Size = espSettings.HealthSize

        local headPos, onHead = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.3, 0))
        local rootPos, onRoot = Camera:WorldToViewportPoint(hrp.Position)
        local legPos, onLeg = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0))

        if not (onHead and onRoot and onLeg) then
            for _, d in ipairs({ box, boxO, hpBar, nameT, hpT }) do
                d.Visible = false
            end
            return
        end

        local rawH = math.abs(headPos.Y - legPos.Y)
        local H = rawH * 1.5
        local W = H / 1.3
        local pos = Vector2.new(rootPos.X - W / 2, headPos.Y - (H - rawH) / 2)

        local alpha = math.clamp(1 - (distance / espSettings.MaxDistance), 0.3, 1)
        local finalAlpha = alpha * espSettings.BoxTransparency

        if Toggles.NPCShowBox and Toggles.NPCShowBox.Value then
            box.Position = pos
            box.Size = Vector2.new(W, H)
            box.Visible = true
            box.Transparency = finalAlpha

            boxO.Position = pos
            boxO.Size = Vector2.new(W, H)
            boxO.Visible = true
            boxO.Transparency = finalAlpha * 0.3
        else
            box.Visible = false
            boxO.Visible = false
        end

        if Toggles.NPCShowHealthBar and Toggles.NPCShowHealthBar.Value then
            local ratio = hum.Health / hum.MaxHealth
            hpBar.Color = Color3.fromHSV(ratio / 3, 1, 1)
            hpBar.Position = Vector2.new(pos.X - 6, pos.Y + H * (1 - ratio))
            hpBar.Size = Vector2.new(2, H * ratio)
            hpBar.Visible = true
            hpBar.Transparency = finalAlpha
        else
            hpBar.Visible = false
        end

        if Toggles.NPCShowName and Toggles.NPCShowName.Value then
            nameT.Text = npc.Name
            nameT.Position = Vector2.new(rootPos.X, pos.Y - 20)
            nameT.Visible = true
            nameT.Transparency = alpha
        else
            nameT.Visible = false
        end

        if Toggles.NPCShowHealth and Toggles.NPCShowHealth.Value then
            local hp = math.floor(hum.Health)
            local mx = math.floor(hum.MaxHealth)
            hpT.Text = string.format('[%d/%d]', hp, mx)
            hpT.Position = Vector2.new(rootPos.X, pos.Y - 5)
            hpT.Visible = true
            hpT.Transparency = alpha
        else
            hpT.Visible = false
        end
    end)

    local ancConn = npc.AncestryChanged:Connect(function(_, parent)
        if not parent then
            cleanNpcEsp(npc)
        end
    end)

    ESP_NPC[npc] = {
        conn = conn,
        ancConn = ancConn,
        draw = { box, boxO, hpBar, nameT, hpT },
    }
end

local function attachNpc(npc)
    if npc:IsA('Model') and npc:FindFirstChildOfClass('Humanoid') then
        buildNpcEsp(npc)
    end
end

local NPCFolder = Workspace:FindFirstChild('NPCs')
if NPCFolder then
    for _, npc in ipairs(NPCFolder:GetChildren()) do
        attachNpc(npc)
    end
    NPCFolder.ChildAdded:Connect(attachNpc)
    NPCFolder.ChildRemoved:Connect(cleanNpcEsp)
end

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- COMBAT FEATURES
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

local QTEEnabled = false
local QTEThread = nil
local QTEOptions = { 'MagicQTE', 'SwordQTE', 'FistQTE', 'DaggerQTE', 'SpearQTE' }
local SelectedQTE = 'SwordQTE'

local function startQTE()
    QTEThread = task.spawn(function()
        while QTEEnabled do
            pcall(function()
                RemoteFunction:FireServer(true, SelectedQTE)
            end)
            task.wait(0.5)
        end
    end)
end

local function stopQTE()
    QTEEnabled = false
    if QTEThread then
        task.cancel(QTEThread)
        QTEThread = nil
    end
end

local AutoEscapeEnabled = false
local EscapeThread = nil

local function startEscape()
    EscapeThread = task.spawn(function()
        while AutoEscapeEnabled do
            pcall(function()
                PlayerTurnInput:InvokeServer('Escape')
            end)
            task.wait(0.5)
        end
    end)
end

local function stopEscape()
    AutoEscapeEnabled = false
    if EscapeThread then
        task.cancel(EscapeThread)
        EscapeThread = nil
    end
end

local autoDodgeEnabled = false
local dodgeThread = nil

local function startAutoDodge()
    dodgeThread = task.spawn(function()
        while autoDodgeEnabled do
            pcall(function()
                RemoteFunction:FireServer({ true, true }, 'DodgeMinigame')
            end)
            task.wait(0.1)
        end
    end)
end

local function stopAutoDodge()
    autoDodgeEnabled = false
    if dodgeThread then
        task.cancel(dodgeThread)
        dodgeThread = nil
    end
end

local runScript = false
local SelectedAttack = 'Strike'

local function findBattleFolder()
    for _, battle in ipairs(FightsFolder:GetChildren()) do
        if battle:IsA('Folder') and battle.Name:sub(1, 6) == 'Battle' then
            local Team1 = battle:FindFirstChild('Team1')
            local Team2 = battle:FindFirstChild('Team2')
            if Team1 and Team2 and Team1:FindFirstChild(LocalPlayer.Name) then
                return battle, Team1, Team2
            end
        end
    end
    return nil, nil, nil
end

local function processTeam2(Team2)
    for _, obj in ipairs(Team2:GetChildren()) do
        if obj:IsA('ObjectValue') then
            local targetName = obj.Name
            local livingFolder = Workspace:FindFirstChild('Living')
            if livingFolder then
                local target = livingFolder:FindFirstChild(targetName)
                if target then
                    pcall(function()
                        PlayerTurnInput:InvokeServer('Attack', SelectedAttack, { Attacking = target })
                    end)
                    task.wait(0.5)
                end
            end
        end
    end
end

local selectedBattle, selectedTeam2 = nil, nil

task.spawn(function()
    while true do
        if runScript then
            if selectedBattle and (not selectedBattle.Parent or not selectedBattle:IsDescendantOf(FightsFolder)) then
                selectedBattle = nil
                selectedTeam2 = nil
            end
            if not selectedBattle then
                local battle, Team1, Team2 = findBattleFolder()
                if battle then
                    selectedBattle = battle
                    selectedTeam2 = Team2
                end
            else
                processTeam2(selectedTeam2)
            end
            task.wait(1)
        else
            selectedBattle = nil
            selectedTeam2 = nil
            task.wait(1)
        end
    end
end)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- MOVEMENT FEATURES
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

local flySettings = { speed = 50, enabled = false }
local speedSettings = { speed = 16, enabled = false }
local infJumpEnabled = false

local function startFly()
    local flyLoop
    flyLoop = RunService.RenderStepped:Connect(function()
        if not flySettings.enabled or not Character or not HumanoidRootPart then
            if flyLoop then
                flyLoop:Disconnect()
            end
            return
        end

        local moveDir = Vector3.new()
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDir = moveDir + Camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDir = moveDir - Camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDir = moveDir - Camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDir = moveDir + Camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveDir = moveDir + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
            moveDir = moveDir - Vector3.new(0, 1, 0)
        end

        HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
        HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero

        if moveDir.Magnitude > 0 then
            moveDir = moveDir.Unit
            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + (moveDir * (flySettings.speed * RunService.RenderStepped:Wait()))
        end
    end)
end

RunService.Stepped:Connect(function()
    if speedSettings.enabled and Character and Character:FindFirstChild('Humanoid') then
        Character.Humanoid.WalkSpeed = speedSettings.speed
    elseif Character and Character:FindFirstChild('Humanoid') then
        Character.Humanoid.WalkSpeed = 16
    end
end)

UserInputService.JumpRequest:Connect(function()
    if infJumpEnabled and Character and Character:FindFirstChild('Humanoid') then
        Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- FARMING FEATURES
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

local IsTeleporting = false
local AutoFarmEnabled = false
local NoClipEnabled = false
local FarmConnection = nil
local NoclipConnection = nil
local ItemsFolder = Workspace:FindFirstChild('SpawnedItems')
local itemCache = {}

if ItemsFolder then
    for _, child in ipairs(ItemsFolder:GetChildren()) do
        table.insert(itemCache, child)
    end
    ItemsFolder.ChildAdded:Connect(function(child)
        table.insert(itemCache, child)
    end)
    ItemsFolder.ChildRemoved:Connect(function(child)
        for i, c in ipairs(itemCache) do
            if c == child then
                table.remove(itemCache, i)
                break
            end
        end
    end)
end

local function tweenToPosition(targetPosition, speed)
    if not HumanoidRootPart or not HumanoidRootPart.Parent then
        return
    end

    local dist = (HumanoidRootPart.Position - targetPosition).Magnitude
    local tweenInfo = TweenInfo.new(dist / speed, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(HumanoidRootPart, tweenInfo, { CFrame = CFrame.new(targetPosition) })
    tween:Play()
    tween.Completed:Wait()
end

local function ensurePrimaryPart(item)
    if not item:IsA('Model') then
        return nil
    end
    if item.PrimaryPart then
        return item.PrimaryPart
    end
    for _, part in ipairs(item:GetDescendants()) do
        if part:IsA('BasePart') then
            pcall(function()
                item.PrimaryPart = part
            end)
            return part
        end
    end
    return nil
end

local function findNearestItem()
    if #itemCache == 0 then
        return nil, math.huge
    end
    if not HumanoidRootPart or not HumanoidRootPart.Parent then
        return nil, math.huge
    end

    local nearest, shortestDist = nil, math.huge
    for _, item in ipairs(itemCache) do
        if item and item.Parent == ItemsFolder and item:IsA('Model') then
            local primary = ensurePrimaryPart(item)
            local handle = item:FindFirstChild('Handle', true)
            local clickDetector = handle and handle:FindFirstChild('ClickPart') and handle.ClickPart:FindFirstChild('ClickDetector')
            if primary and clickDetector then
                local dist = (HumanoidRootPart.Position - primary.Position).Magnitude
                if dist < shortestDist then
                    shortestDist = dist
                    nearest = item
                end
            end
        end
    end
    return nearest, shortestDist
end

local function safeCollect()
    if not AutoFarmEnabled or IsTeleporting then
        return
    end
    IsTeleporting = true

    pcall(function()
        local item, distance = findNearestItem()
        if not item or distance == math.huge then
            return
        end

        local primary = ensurePrimaryPart(item)
        local handle = item:FindFirstChild('Handle', true)
        local clickDetector = handle and handle:FindFirstChild('ClickPart') and handle.ClickPart:FindFirstChild('ClickDetector')

        if primary and clickDetector then
            tweenToPosition(primary.Position + Vector3.new(0, 3, 0), 240)
            fireclickdetector(clickDetector)
            task.wait(0.3)
        end
    end)

    IsTeleporting = false
end

local function enableNoClip()
    if not NoclipConnection then
        NoclipConnection = RunService.Stepped:Connect(function()
            if Character and NoClipEnabled then
                for _, part in ipairs(Character:GetDescendants()) do
                    if part:IsA('BasePart') then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end
end

local function disableNoClip()
    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end
    if Character then
        for _, part in ipairs(Character:GetDescendants()) do
            if part:IsA('BasePart') then
                part.CanCollide = true
            end
        end
    end
end

local BypassFallDamageEnabled = false
local oldNamecall
oldNamecall = hookmetamethod(game, '__namecall', newcclosure(function(self, ...)
    local method = getnamecallmethod()
    if BypassFallDamageEnabled and method == 'FireServer' and self.Name == 'EnviroEffects' then
        return
    end
    return oldNamecall(self, ...)
end))

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- NPC TOOLS
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

local allNPCNames = {}
local currentNPC = nil

local function getAllNPCNames()
    local names = {}
    if NPCFolder then
        for _, npc in ipairs(NPCFolder:GetChildren()) do
            table.insert(names, npc.Name)
        end
    end
    return names
end

local function teleportToNPC(npcName)
    if not npcName or npcName == '' or not NPCFolder then
        return
    end

    local npcModel = NPCFolder:FindFirstChild(npcName)
    if not npcModel then
        return
    end

    local targetPart = npcModel:FindFirstChild('HumanoidRootPart') or npcModel:FindFirstChildWhichIsA('BasePart')
    if not targetPart or not HumanoidRootPart or not HumanoidRootPart.Parent then
        return
    end

    tweenToPosition(targetPart.Position + Vector3.new(0, 3, 0), 240)
end

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- INVENTORY
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

local function findItemInInventory(itemName)
    local inventory = InventoryManage:InvokeServer('GetInventory')
    for _, item in ipairs(inventory) do
        if item.Name == itemName then
            return item
        end
    end
    return nil
end

local AutoAbhorrentEnabled = false
local AutoAbhorrentThread = nil

local function startAbhorrent()
    AutoAbhorrentThread = task.spawn(function()
        while AutoAbhorrentEnabled do
            pcall(function()
                local item = findItemInInventory('Abhorrent Elixir')
                if item then
                    InventoryManage:FireServer('Equip', 'Abhorrent Elixir', item)
                    task.wait(0.7)
                    InventoryManage:FireServer('Use', 'Abhorrent Elixir', item)
                end
            end)
            task.wait(40)
        end
    end)
end

local function stopAbhorrent()
    AutoAbhorrentEnabled = false
    if AutoAbhorrentThread then
        task.cancel(AutoAbhorrentThread)
        AutoAbhorrentThread = nil
    end
end

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- UTILITIES
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

local AntiVoidEnabled = false
local AntiVoidLoop = nil

local function deleteAllVoid()
    for _, model in ipairs(Workspace:GetChildren()) do
        if model:IsA('Model') then
            local voidPart = model:FindFirstChild('Void')
            if voidPart and voidPart:IsA('BasePart') then
                pcall(function()
                    model:Destroy()
                end)
            end
        end
    end
end

local function startAntiVoid()
    AntiVoidLoop = task.spawn(function()
        while AntiVoidEnabled do
            pcall(deleteAllVoid)
            task.wait(0.3)
        end
    end)
end

local function stopAntiVoid()
    AntiVoidEnabled = false
    if AntiVoidLoop then
        task.cancel(AntiVoidLoop)
        AntiVoidLoop = nil
    end
end

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- UI
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- Combat Group
local combatGroup = Tabs.Main:AddLeftGroupbox('Combat', 'swords')

combatGroup:AddDropdown('QTEOption', {
    Values = QTEOptions,
    Default = 1,
    Multi = false,
    Text = 'QTE Option',
    Tooltip = 'Select QTE type',
    Callback = function(value)
        SelectedQTE = value
    end,
})

combatGroup:AddToggle('AutoQTE', {
    Text = 'Auto QTE',
    Default = false,
    Tooltip = 'Automatically complete QTE events',
    Callback = function(value)
        if value then
            QTEEnabled = true
            startQTE()
        else
            stopQTE()
        end
    end,
})

combatGroup:AddToggle('AutoEscape', {
    Text = 'Auto Escape',
    Default = false,
    Tooltip = 'Automatically escape from battles',
    Callback = function(value)
        if value then
            AutoEscapeEnabled = true
            startEscape()
        else
            stopEscape()
        end
    end,
})

combatGroup:AddToggle('AutoDodge', {
    Text = 'Auto Dodge',
    Default = false,
    Tooltip = 'Automatically dodge attacks',
    Callback = function(value)
        autoDodgeEnabled = value
        if autoDodgeEnabled then
            startAutoDodge()
        else
            stopAutoDodge()
        end
    end,
})

combatGroup:AddDivider()

combatGroup:AddToggle('AutoAttack', {
    Text = 'Auto Attack',
    Default = false,
    Tooltip = 'Automatically attack enemies',
    Callback = function(value)
        runScript = value
    end,
})

combatGroup:AddDropdown('AttackSelection', {
    Values = { 'Strike' },
    Default = 1,
    Multi = false,
    Text = 'Attack Type',
    Tooltip = 'Select attack type',
    Callback = function(value)
        SelectedAttack = value
    end,
})

-- Movement Group
local movementGroup = Tabs.Main:AddRightGroupbox('Movement', 'move')

movementGroup
    :AddToggle('Fly', {
        Text = 'Fly',
        Default = false,
        Tooltip = 'Fly mode (WASD + Space/Ctrl)',
        Callback = function(value)
            flySettings.enabled = value
            if value then
                task.spawn(startFly)
                if Character and Character:FindFirstChild('Humanoid') then
                    Character.Humanoid.PlatformStand = true
                end
            else
                if Character and Character:FindFirstChild('Humanoid') then
                    Character.Humanoid.PlatformStand = false
                end
            end
        end,
    })
    :AddKeyPicker('FlyKey', {
        Default = 'F1',
        NoUI = true,
        Text = 'Fly Keybind',
        Mode = 'Toggle',
        SyncToggleState = true,
    })

movementGroup:AddSlider('FlySpeed', {
    Text = 'Fly Speed',
    Default = 50,
    Min = 10,
    Max = 300,
    Rounding = 0,
    Callback = function(v)
        flySettings.speed = v
    end,
})

movementGroup:AddDivider()

movementGroup
    :AddToggle('Speed', {
        Text = 'Speed Hack',
        Default = false,
        Tooltip = 'Modify walk speed',
        Callback = function(value)
            speedSettings.enabled = value
        end,
    })
    :AddKeyPicker('SpeedKey', {
        Default = 'F2',
        NoUI = true,
        Text = 'Speed Keybind',
        Mode = 'Toggle',
        SyncToggleState = true,
    })

movementGroup:AddSlider('WalkSpeed', {
    Text = 'Walk Speed',
    Default = 16,
    Min = 16,
    Max = 300,
    Rounding = 0,
    Callback = function(v)
        speedSettings.speed = v
    end,
})

movementGroup:AddDivider()

movementGroup
    :AddToggle('InfJump', {
        Text = 'Infinite Jump',
        Default = false,
        Tooltip = 'Jump infinitely',
        Callback = function(value)
            infJumpEnabled = value
        end,
    })
    :AddKeyPicker('InfJumpKey', {
        Default = 'F3',
        NoUI = true,
        Text = 'Inf Jump Keybind',
        Mode = 'Toggle',
        SyncToggleState = true,
    })

-- Farming Group
local farmGroup = Tabs.Main:AddLeftGroupbox('Farming', 'package')

farmGroup:AddToggle('AutoFarm', {
    Text = 'Auto Farm Items',
    Default = false,
    Tooltip = 'Automatically farm spawned items',
    Callback = function(value)
        AutoFarmEnabled = value
        if value then
            if not FarmConnection then
                FarmConnection = RunService.Heartbeat:Connect(function()
                    if AutoFarmEnabled and not IsTeleporting then
                        safeCollect()
                    end
                end)
            end
        else
            if FarmConnection then
                FarmConnection:Disconnect()
                FarmConnection = nil
            end
            IsTeleporting = false
        end
    end,
})

farmGroup:AddToggle('NoClip', {
    Text = 'NoClip',
    Default = false,
    Tooltip = 'Walk through walls',
    Callback = function(value)
        NoClipEnabled = value
        if value then
            enableNoClip()
        else
            disableNoClip()
        end
    end,
})

farmGroup:AddToggle('BypassFallDamage', {
    Text = 'Bypass Fall Damage',
    Default = false,
    Tooltip = 'Prevent fall damage',
    Callback = function(value)
        BypassFallDamageEnabled = value
    end,
})

-- NPC Group
local npcGroup = Tabs.Main:AddRightGroupbox('NPC Tools', 'users')

allNPCNames = getAllNPCNames()

npcGroup:AddDropdown('NPCList', {
    Values = allNPCNames,
    Default = 1,
    Multi = false,
    Text = 'NPC List',
    Tooltip = 'Select an NPC (searchable)',
    Searchable = true,
    Callback = function(value)
        currentNPC = value
    end,
})

npcGroup:AddButton({
    Text = 'Teleport to NPC',
    Func = function()
        if currentNPC then
            teleportToNPC(currentNPC)
        end
    end,
    Tooltip = 'Teleport to selected NPC',
})

npcGroup:AddButton({
    Text = 'Refresh NPC List',
    Func = function()
        allNPCNames = getAllNPCNames()
        Options.NPCList:Refresh(allNPCNames)
    end,
    Tooltip = 'Refresh the NPC list',
})

npcGroup:AddDivider()

npcGroup:AddToggle('NPCShowBox', {
    Text = 'Show Box',
    Default = false,
    Tooltip = 'Show box around NPCs',
}):AddColorPicker('NPCBoxColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Box Color',
    Callback = function(value)
        espSettings.BoxColor = value
    end,
})

npcGroup:AddToggle('NPCShowHealthBar', {
    Text = 'Show Health Bar',
    Default = false,
    Tooltip = 'Show health bar',
})

npcGroup:AddToggle('NPCShowName', {
    Text = 'Show Name',
    Default = false,
    Tooltip = 'Show NPC name',
}):AddColorPicker('NPCNameColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Name Color',
    Callback = function(value)
        espSettings.NameColor = value
    end,
})

npcGroup:AddToggle('NPCShowHealth', {
    Text = 'Show Health',
    Default = false,
    Tooltip = 'Show health text',
}):AddColorPicker('NPCHealthColor', {
    Default = Color3.fromRGB(0, 255, 0),
    Title = 'Health Color',
    Callback = function(value)
        espSettings.HealthColor = value
    end,
})

Toggles.NPCShowBox:OnChanged(function()
    espSettings.Enabled = Toggles.NPCShowBox.Value or Toggles.NPCShowHealthBar.Value or Toggles.NPCShowName.Value or Toggles.NPCShowHealth.Value
end)

Toggles.NPCShowHealthBar:OnChanged(function()
    espSettings.Enabled = Toggles.NPCShowBox.Value or Toggles.NPCShowHealthBar.Value or Toggles.NPCShowName.Value or Toggles.NPCShowHealth.Value
end)

Toggles.NPCShowName:OnChanged(function()
    espSettings.Enabled = Toggles.NPCShowBox.Value or Toggles.NPCShowHealthBar.Value or Toggles.NPCShowName.Value or Toggles.NPCShowHealth.Value
end)

Toggles.NPCShowHealth:OnChanged(function()
    espSettings.Enabled = Toggles.NPCShowBox.Value or Toggles.NPCShowHealthBar.Value or Toggles.NPCShowName.Value or Toggles.NPCShowHealth.Value
end)

-- Inventory Group
local invGroup = Tabs.Main:AddLeftGroupbox('Inventory', 'backpack')

invGroup:AddToggle('AutoAbhorrent', {
    Text = 'Auto Abhorrent',
    Default = false,
    Tooltip = 'Automatically use Abhorrent Elixir',
    Callback = function(value)
        if value then
            AutoAbhorrentEnabled = true
            startAbhorrent()
        else
            stopAbhorrent()
        end
    end,
})

-- Utilities Group
local utilGroup = Tabs.Main:AddRightGroupbox('Utilities', 'wrench')

utilGroup:AddToggle('AntiVoid', {
    Text = 'Anti Void',
    Default = false,
    Tooltip = 'Automatically destroy void parts as they spawn',
    Callback = function(value)
        if value then
            AntiVoidEnabled = true
            startAntiVoid()
        else
            stopAntiVoid()
        end
    end,
})

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- UI SETTINGS
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu', 'wrench')

MenuGroup:AddToggle('KeybindMenuOpen', {
    Default = Library.KeybindFrame.Visible,
    Text = 'Open Keybind Menu',
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end,
})

MenuGroup:AddToggle('ShowCustomCursor', {
    Text = 'Custom Cursor',
    Default = true,
    Callback = function(value)
        Library.ShowCustomCursor = value
    end,
})

MenuGroup:AddDropdown('NotificationSide', {
    Values = { 'Left', 'Right' },
    Default = 'Right',
    Text = 'Notification Side',
    Callback = function(value)
        Library:SetNotifySide(value)
    end,
})

MenuGroup:AddDivider()

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'RightShift',
    NoUI = true,
    Text = 'Menu keybind',
})

MenuGroup:AddButton({
    Text = 'Unload',
    Func = function()
        Library:Unload()
    end,
})

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('Eisha')
SaveManager:SetFolder('Eisha/Settings')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()

Library:OnUnload(function()
    stopQTE()
    stopEscape()
    stopAutoDodge()
    stopAbhorrent()
    stopAntiVoid()
    disableNoClip()

    if FarmConnection then
        FarmConnection:Disconnect()
    end

    for npc, _ in pairs(ESP_NPC) do
        cleanNpcEsp(npc)
    end

    getgenv().ArcaneLoaded = nil
end)

getgenv().ArcaneLoaded = true

Library:Notify({
    Title = 'Eisha',
    Description = 'Loaded successfully!',
    Time = 5,
})
